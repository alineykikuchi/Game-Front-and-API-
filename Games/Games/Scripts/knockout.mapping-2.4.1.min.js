/// Knockout Mapping plugin v2.4.1
/// (c) 2013 Steven Sanderson, Roy Jacobs - http://knockoutjs.com/
/// License: MIT (http://www.opensource.org/licenses/mit-license.php)
!function (e) { "function" == typeof require && "object" == typeof exports && "object" == typeof module ? e(require("knockout"), exports) : "function" == typeof define && define.amd ? define(["knockout", "exports"], e) : e(ko, ko.mapping = {}) }(function (C, R) { var $, q, G = !0, V = "__ko_mapping__", z = C.dependentObservable, i = 0, o = ["create", "update", "key", "arrayChanged"], B = {}, e = { include: ["_destroy"], ignore: [], copy: [], observe: [] }, u = e; function s(e, r) { for (var t = {}, n = e.length - 1; 0 <= n; --n) t[e[n]] = e[n]; for (n = r.length - 1; 0 <= n; --n) t[r[n]] = r[n]; var a = []; for (var i in t) a.push(t[i]); return a } function p(e, r) { var t; for (var n in r) if (r.hasOwnProperty(n) && r[n]) if (t = R.getType(e[n]), n && e[n] && "array" !== t && "string" !== t) p(e[n], r[n]); else { var a = "array" === R.getType(e[n]) && "array" === R.getType(r[n]); e[n] = a ? s(e[n], r[n]) : r[n] } } function H(e, r) { var t = {}; return p(t, e), p(t, r), t } function v(e, r) { for (var t = H({}, e), n = o.length - 1; 0 <= n; n--) { var a = o[n]; t[a] && (t[""] instanceof Object || (t[""] = {}), t[""][a] = t[a], delete t[a]) } return r && (t.ignore = f(r.ignore, t.ignore), t.include = f(r.include, t.include), t.copy = f(r.copy, t.copy), t.observe = f(r.observe, t.observe)), t.ignore = f(t.ignore, u.ignore), t.include = f(t.include, u.include), t.copy = f(t.copy, u.copy), t.observe = f(t.observe, u.observe), t.mappedProperties = t.mappedProperties || {}, t.copiedProperties = t.copiedProperties || {}, t } function f(e, r) { return "array" !== R.getType(e) && (e = "undefined" === R.getType(e) ? [] : [e]), "array" !== R.getType(r) && (r = "undefined" === R.getType(r) ? [] : [r]), C.utils.arrayGetDistinctValues(e.concat(r)) } function K(e, r, t) { for (var n = 0, a = e.length; n < a; n++) if (!0 !== t[n] && e[n] === r) return n; return null } function l(e, r) { var t; return r && (t = r(e)), "undefined" === R.getType(t) && (t = e), C.utils.unwrapObservable(t) } function L(e, r, t) { for (var n = 0, a = (e = C.utils.unwrapObservable(e)).length; n < a; n++) { var i = e[n]; if (l(i, t) === r) return i } throw new Error("When calling ko.update*, the key '" + r + "' was not found!") } function Q(e, r) { return C.utils.arrayMap(C.utils.unwrapObservable(e), function (e) { return r ? l(e, r) : e }) } function U(e, r) { if ("array" === R.getType(e)) for (var t = 0; t < e.length; t++) r(t); else for (var n in e) r(n) } function X(e) { var r = R.getType(e); return ("object" === r || "array" === r) && null !== e } function a() { var n = [], a = []; this.save = function (e, r) { var t = C.utils.arrayIndexOf(n, e); 0 <= t ? a[t] = r : (n.push(e), a.push(r)) }, this.get = function (e) { var r = C.utils.arrayIndexOf(n, e); return 0 <= r ? a[r] : void 0 } } function c() { var n = {}, t = function (e) { var r; try { r = e } catch (e) { r = "$$$" } var t = n[r]; return void 0 === t && (t = new a, n[r] = t), t }; this.save = function (e, r) { t(e).save(e, r) }, this.get = function (e) { return t(e).get(e) } } R.isMapped = function (e) { var r = C.utils.unwrapObservable(e); return r && r[V] }, R.fromJS = function (e) { if (0 == arguments.length) throw new Error("When calling ko.fromJS, pass the object you want to convert."); try { var r, t; i++ || ($ = [], q = new c), 2 == arguments.length && (arguments[1][V] ? t = arguments[1] : r = arguments[1]), 3 == arguments.length && (r = arguments[1], t = arguments[2]), t && (r = H(r, t[V])); var n = function i(o, u, s, n, r, p, e) { var t = "array" === R.getType(C.utils.unwrapObservable(u)); p = p || ""; if (R.isMapped(o)) { var a = C.utils.unwrapObservable(o)[V]; s = H(a, s) } var f = { data: u, parent: e || r }; var l = function () { return s[n] && s[n].create instanceof Function }; var v = function (e) { return function (o, e) { var r = C.dependentObservable; C.dependentObservable = function (e, r, t) { t = t || {}, e && "object" == typeof e && (t = e); var n = t.deferEvaluation, a = !1; t.deferEvaluation = !0; var i = new z(e, r, t); return n || (i = function (r) { var e = C.dependentObservable; C.dependentObservable = z; var t = C.isWriteableObservable(r); C.dependentObservable = e; var n = z({ read: function () { return a || (C.utils.arrayRemoveItem(o, r), a = !0), r.apply(r, arguments) }, write: t && function (e) { return r(e) }, deferEvaluation: !0 }); G && (n._wrapper = !0); return n.__DO = r, n }(i), o.push(i)), i }, C.dependentObservable.fn = z.fn, C.computed = C.dependentObservable; var t = e(); return C.dependentObservable = r, C.computed = C.dependentObservable, t }($, function () { return C.utils.unwrapObservable(r) instanceof Array ? s[n].create({ data: e || f.data, parent: f.parent, skip: B }) : s[n].create({ data: e || f.data, parent: f.parent }) }) }; var c = function () { return s[n] && s[n].update instanceof Function }; var d = function (e, r) { var t = { data: r || f.data, parent: f.parent, target: C.utils.unwrapObservable(e) }; return C.isWriteableObservable(e) && (t.observable = e), s[n].update(t) }; var b = q.get(u); if (b) return b; n = n || ""; if (t) { var y = [], g = !1, O = function (e) { return e }; s[n] && s[n].key && (O = s[n].key, g = !0), C.isObservable(o) || ((o = C.observableArray([])).mappedRemove = function (r) { var t = "function" == typeof r ? r : function (e) { return e === O(r) }; return o.remove(function (e) { return t(O(e)) }) }, o.mappedRemoveAll = function (e) { var r = Q(e, O); return o.remove(function (e) { return -1 != C.utils.arrayIndexOf(r, O(e)) }) }, o.mappedDestroy = function (r) { var t = "function" == typeof r ? r : function (e) { return e === O(r) }; return o.destroy(function (e) { return t(O(e)) }) }, o.mappedDestroyAll = function (e) { var r = Q(e, O); return o.destroy(function (e) { return -1 != C.utils.arrayIndexOf(r, O(e)) }) }, o.mappedIndexOf = function (e) { var r = Q(o(), O), t = O(e); return C.utils.arrayIndexOf(r, t) }, o.mappedGet = function (e) { return o()[o.mappedIndexOf(e)] }, o.mappedCreate = function (e) { if (-1 !== o.mappedIndexOf(e)) throw new Error("There already is an object with the key that you specified."); var r = l() ? v(e) : e; if (c()) { var t = d(r, e); C.isWriteableObservable(r) ? r(t) : r = t } return o.push(r), r }); var h = Q(C.utils.unwrapObservable(o), O).sort(), w = Q(u, O); g && w.sort(); var m, k, T = C.utils.compareArrays(h, w), x = {}, j = C.utils.unwrapObservable(u), I = {}, J = !0; for (m = 0, k = j.length; m < k; m++) { var E = O(j[m]); if (void 0 === E || E instanceof Object) { J = !1; break } I[E] = j[m] } var P = [], S = 0; for (m = 0, k = T.length; m < k; m++) { var _, E = T[m], N = p + "[" + m + "]"; switch (E.status) { case "added": var W = J ? I[E.value] : L(C.utils.unwrapObservable(u), E.value, O); _ = i(void 0, W, s, n, o, N, r), l() || (_ = C.utils.unwrapObservable(_)); var D = K(C.utils.unwrapObservable(u), W, x); _ === B ? S++ : P[D - S] = _, x[D] = !0; break; case "retained": var W = J ? I[E.value] : L(C.utils.unwrapObservable(u), E.value, O); _ = L(o, E.value, O), i(_, W, s, n, o, N, r); var D = K(C.utils.unwrapObservable(u), W, x); P[D] = _, x[D] = !0; break; case "deleted": _ = L(o, E.value, O) } y.push({ event: E.status, item: _ }) } o(P), s[n] && s[n].arrayChanged && C.utils.arrayForEach(y, function (e) { s[n].arrayChanged(e.event, e.item) }) } else if (X(u)) { if (!(o = C.utils.unwrapObservable(o))) { if (l()) { var F = v(); return c() && (F = d(F)), F } if (c()) return d(F); o = {} } if (c() && (o = d(o)), q.save(u, o), c()) return o; U(u, function (e) { var r = p.length ? p + "." + e : e; if (-1 == C.utils.arrayIndexOf(s.ignore, r)) if (-1 == C.utils.arrayIndexOf(s.copy, r)) { if ("object" != typeof u[e] && "array" != typeof u[e] && 0 < s.observe.length && -1 == C.utils.arrayIndexOf(s.observe, r)) return o[e] = u[e], void (s.copiedProperties[r] = !0); var t = q.get(u[e]), n = i(o[e], u[e], s, e, o, r, o), a = t || n; if (0 < s.observe.length && -1 == C.utils.arrayIndexOf(s.observe, r)) return o[e] = a(), void (s.copiedProperties[r] = !0); C.isWriteableObservable(o[e]) ? (a = C.utils.unwrapObservable(a), o[e]() !== a && o[e](a)) : (a = void 0 === o[e] ? a : C.utils.unwrapObservable(a), o[e] = a), s.mappedProperties[r] = !0 } else o[e] = u[e] }) } else switch (R.getType(u)) { case "function": c() ? C.isWriteableObservable(u) ? (u(d(u)), o = u) : o = d(u) : o = u; break; default: if (C.isWriteableObservable(o)) { if (c()) { var A = d(o); return o(A), A } var A = C.utils.unwrapObservable(u); return o(A), A } var M = l() || c(); if (o = l() ? v() : C.observable(C.utils.unwrapObservable(u)), c() && o(d(o)), M) return o } return o }(t, e, r = v(r)); if (t && (n = t), !--i) for (; $.length;) { var a = $.pop(); a && (a(), a.__DO.throttleEvaluation = a.throttleEvaluation) } return n[V] = H(n[V], r), n } catch (e) { throw i = 0, e } }, R.fromJSON = function (e) { var r = C.utils.parseJson(e); return arguments[0] = r, R.fromJS.apply(this, arguments) }, R.updateFromJS = function (e) { throw new Error("ko.mapping.updateFromJS, use ko.mapping.fromJS instead. Please note that the order of parameters is different!") }, R.updateFromJSON = function (e) { throw new Error("ko.mapping.updateFromJSON, use ko.mapping.fromJSON instead. Please note that the order of parameters is different!") }, R.toJS = function (e, r) { if (u || R.resetDefaultOptions(), 0 == arguments.length) throw new Error("When calling ko.mapping.toJS, pass the object you want to convert."); if ("array" !== R.getType(u.ignore)) throw new Error("ko.mapping.defaultOptions().ignore should be an array."); if ("array" !== R.getType(u.include)) throw new Error("ko.mapping.defaultOptions().include should be an array."); if ("array" !== R.getType(u.copy)) throw new Error("ko.mapping.defaultOptions().copy should be an array."); return r = v(r, e[V]), R.visitModel(e, function (e) { return C.utils.unwrapObservable(e) }, r) }, R.toJSON = function (e, r) { var t = R.toJS(e, r); return C.utils.stringifyJson(t) }, R.defaultOptions = function () { if (!(0 < arguments.length)) return u; u = arguments[0] }, R.resetDefaultOptions = function () { u = { include: e.include.slice(0), ignore: e.ignore.slice(0), copy: e.copy.slice(0) } }, R.getType = function (e) { if (e && "object" == typeof e) { if (e.constructor === Date) return "date"; if (e.constructor === Array) return "array" } return typeof e }, R.visitModel = function (e, u, s) { var p; (s = s || {}).visitedObjects = s.visitedObjects || new c; var f = C.utils.unwrapObservable(e); if (!X(f)) return u(e, s.parentName); s = v(s, f[V]), u(e, s.parentName), p = "array" === R.getType(f) ? [] : {}, s.visitedObjects.save(e, p); var l = s.parentName; return U(f, function (e) { if (!s.ignore || -1 == C.utils.arrayIndexOf(s.ignore, e)) { var r, t, n, a, i = f[e]; if (s.parentName = (t = f, n = e, a = (r = l) || "", "array" === R.getType(t) ? r && (a += "[" + n + "]") : (r && (a += "."), a += n), a), -1 !== C.utils.arrayIndexOf(s.copy, e) || -1 !== C.utils.arrayIndexOf(s.include, e) || !f[V] || !f[V].mappedProperties || f[V].mappedProperties[e] || !f[V].copiedProperties || f[V].copiedProperties[e] || "array" === R.getType(f)) switch (R.getType(C.utils.unwrapObservable(i))) { case "object": case "array": case "undefined": var o = s.visitedObjects.get(i); p[e] = "undefined" !== R.getType(o) ? o : R.visitModel(i, u, s); break; default: p[e] = u(i, s.parentName) } } }), p } });